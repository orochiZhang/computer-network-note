# TCP和UDP

## TCP
1. **面向连接**：TCP接收方与发送方维持了一个状态（三次握手建立连接，四次挥手断开连接），双方都知道对方的存在。    
2. **可靠的**：发送出去的数据对方一定能够接收到，而且是按照发送的顺序收到的。   
3. **面向字节流**
4. **流量控制与拥塞控制**：TCP靠谱通过滑动窗口确保，发送的数据接收方来得及收。TCP无私，发生数据包丢失的时候认为整个网络比较堵，自己放慢数据发送速度。    
5. **只支持一对一**：每一条TCP连接只能是点对点的

## UDP
1. 无连接。
2. 尽最大努力交付；
3. 面向报文
4. 无拥塞控制；
5. 支持一对一、一对多、多对一和多对多的交互通信
6. 首部开销小

## TCP字节流与UDP数据报
客户端通过TCP连接给服务端发送数据，客户端只调用了一次 write，发送了100个字节，但是服务端可以分10次收完，每次10个字节。
也可以调用10次write，每次发10个字节，但是对方可以一次就收完。
假设数据都能到达的情况下，发送的数据量不能大于对方的接收缓存(流量控制)，
如果你硬是要发送过量数据，则对方的缓存满了就会把多出的数据丢弃。

UDP和TCP不同，发送端调用了几次write，接收端必须用相同次数的read读完。
UPD是基于报文的，在接收的时候，每次最多只能读取一个报文，报文和报文是不会合并的，如果缓冲区小于报文长度，则多出的部分会被丢弃。
也就说，如果不指定MSG_PEEK标志，每次读取操作将消耗一个报文。

其实，这种不同是由TCP和UDP的特性决定的。
TCP是面向连接的，也就是说，在连接持续的过程中，socket中收到的数据都是由同一台主机发出的(劫持什么的不考虑)。
因此，知道保证数据是有序的到达就行了，至于每次读取多少数据自己看着办。

而UDP是无连接的协议，也就是说，只要知道接收端的IP和端口，且网络是可达的，任何主机都可以向接收端发送数据。
这时候，如果一次能读取超过一个报文的数据，则会乱套。
比如，主机A向发送了报文P1，主机B发送了报文P2，如果能够读取超过一个报文的数据，那么就会将P1和P2的数据合并在了一起，这样的数据是没有意义的。

### TCP的RTO计算  
假定TCP在开始建立连接时，发送方设定超时重传时间是RTO=6s。    
1. 当发送方接到对方的连接确认报文段时，测量出RTT样本值为1.5s。试计算现在的RTO值。   
2. 当发送方发送数据报文段并接收到确认时，测量出RTT样本值为2.5s。试计算现在的RTO值。

【答案】 
```
根据RFC6298

RTT(1) = 1.5s

SRTT(1) = RTT(1) = 1.5s

RTTVAR(1) = 1.5/2 = 0.75

RTO = 1.5 + 4*0.75 = 4.5s 所以现在RTO的值为4.5s

接着计算第二步 RTT (2) = 2.5

RTTVAR(2) = 3/4 * 0.75 + 1/4 * |1.5 - 2.5| = 13/16

SRTT(2) = 7/8 *1.5 + 1/8*2.5 = 1.625

RTO = 1.625 + 4 * 13/16 = 4.875

当发生超时重传的时候，RTO = RTO\*2，发生第二次重传的时候， RTO\*4, RTO\*8, RTO\*16
```

### TCP拥塞控制     
TCP就是通过这种小速率探测网络拥堵、    
指数增加发送速度、   
检测到丢包、       
发送速率减半、    
直到不再检测到丢包、     
线性增长发送速率、    
检测到丢包、    
再指数减小发送速率…     
TCP流控算法的关键，是基于丢包，有否丢包是唯一的判断依据，是加油门还是踩刹车。

但TCP由于对网络了解的很片面，无法分辨丢包是什么原因造成的：

1）网络真的拥堵而丢包

2）线路质量差CRC校验失败丢、或信号干扰丢

3）IP包乱序而引起的误判

只有情况1是需要踩刹车的，而情况2、3并不需要。

### TCP自动重传请求
自动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层的错误纠正协议之一。它包括停止等待ARQ协议和连续ARQ协议，错误侦测（Error Detection）、正面确认（Positive Acknowledgment）、逾时重传（Retransmission after Timeout）与负面确认继以重传（Negative Acknowledgment and Retransmission）等机制。

传统自动重传请求分成为三种，即停等式(stop-and-wait）ARQ，回退n帧（go-back-n）ARQ，以及选择性重传（selective repeat）ARQ。后两种协议是滑动窗口技术与请求重发技术的结合，由于窗口尺寸开到足够大时，帧在线路上可以连续地流动，因此又称其为连续ARQ协议。三者的区别在于对于出错的数据报文的处理机制不同。三种ARQ协议中，复杂性递增，效率也递增。除了传统的ARQ，还有混合ARQ（Hybrid-ARQ）。
#### 停等式ARQ
在停等式ARQ中，数据报文发送完成之后，发送方等待接收方的状态报告，如果状态报告报文发送成功，发送后续的数据报文，否则重传该报文。

停等式ARQ，发送窗口和接收窗口大小均为1，发送方每发送一帧之后就必须停下来等待接收方的确认返回，仅当接收方确认正确接收后再继续发送下一帧。该方法所需要的缓冲存储空间最小，缺点是信道效率很低。
#### 回退n帧的ARQ
发信侧不用等待收信侧的应答，持续的发送多个帧，假如发现已发送的帧中有错误发生，那么从那个发生错误的帧开始及其之后所有的帧全部再重新发送。

特点：（GDN）复杂度低，但是不必要的帧会再重发，所以大幅度范围内使用的话效率是不高的

例：如果序列号有K bits，那么这个ARQ的协议大小为：2^k-1。
#### 选择性重传ARQ
发信侧不用等待收信侧的应答，持续的发送多个帧，假如发现已发送的帧中有错误发生，那么发信侧将只重新发送那个发生错误的帧。

特点：相对于GDN 复杂度高，但是不需要发送没必要的帧，所以效率高。

例：如果序列号有K bits，那么这个ARQ的协议大小为：2^(k-1)。
#### 混合ARQ
在混合ARQ中，数据报文传送到接收方之后，即使出错也不会被丢弃。接收方指示发送方重传出错报文的部分或者全部信息，将再次收到的报文信息与上次收到的报文信息进行合并，以恢复报文信息。

# socket
基于TCP或者UDP的一种“open—write/read—close”模式的一种实现。所以，Socket其实并不是一个协议。它工作在 OSI 模型会话层（第5层），是为了方便大家直接使用更底层协议（一般是 TCP 或 UDP ）而存在的一个抽象层。

客户端的connect在三次握手的第二个次返回，而服务器端的accept在三次握手的第三次返回。

### 长连接
但是每次TCP通信都open进行三次握手，close的时候进行四次挥手。这样很浪费资源，所以现在常见的socket都是通过心跳包一直保持连接的状态来通信的。

### socket分“标准io socket”和“nio socket”
标准io socket是客户端和服务端建立了连接之后，服务端分配一个线程和客户端通信。但是当客户端的网络不好的时候，服务端负责和该客户端通信的线程就会一直在等待，资源白白浪费。

nio socket使用事件通知的机制，当数据准备好了才会通知服务器端线程进行读写，避免了网络io等待。
简单的思路是一个线程控制一个selector,一个selector可以轮询多个客户端的channel,这样服务器端线程不用等待网络io,只会处理准备好的数据。
